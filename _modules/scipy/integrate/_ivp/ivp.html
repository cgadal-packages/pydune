
<!DOCTYPE html>


<html lang="en" data-content_root="../../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scipy.integrate._ivp.ivp &#8212; pydune  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/pydata-custom.css?v=3bab9780" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../../_static/documentation_options.js?v=7f41d439"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/scipy/integrate/_ivp/ivp';</script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">pydune</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../index.html">
    Home page
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../_examples/index.html">
    Examples and Tutorials
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../_autosummary/pydune.html">
    API reference
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/cgadal-packages/pydune" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../index.html">
    Home page
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../_examples/index.html">
    Examples and Tutorials
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../_autosummary/pydune.html">
    API reference
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/cgadal-packages/pydune" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">scipy.integrate._ivp.ivp</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for scipy.integrate._ivp.ivp</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.bdf</span><span class="w"> </span><span class="kn">import</span> <span class="n">BDF</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.radau</span><span class="w"> </span><span class="kn">import</span> <span class="n">Radau</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.rk</span><span class="w"> </span><span class="kn">import</span> <span class="n">RK23</span><span class="p">,</span> <span class="n">RK45</span><span class="p">,</span> <span class="n">DOP853</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.lsoda</span><span class="w"> </span><span class="kn">import</span> <span class="n">LSODA</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">OptimizeResult</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.common</span><span class="w"> </span><span class="kn">import</span> <span class="n">EPS</span><span class="p">,</span> <span class="n">OdeSolution</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">OdeSolver</span>


<span class="n">METHODS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;RK23&#39;</span><span class="p">:</span> <span class="n">RK23</span><span class="p">,</span>
           <span class="s1">&#39;RK45&#39;</span><span class="p">:</span> <span class="n">RK45</span><span class="p">,</span>
           <span class="s1">&#39;DOP853&#39;</span><span class="p">:</span> <span class="n">DOP853</span><span class="p">,</span>
           <span class="s1">&#39;Radau&#39;</span><span class="p">:</span> <span class="n">Radau</span><span class="p">,</span>
           <span class="s1">&#39;BDF&#39;</span><span class="p">:</span> <span class="n">BDF</span><span class="p">,</span>
           <span class="s1">&#39;LSODA&#39;</span><span class="p">:</span> <span class="n">LSODA</span><span class="p">}</span>


<span class="n">MESSAGES</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;The solver successfully reached the end of the integration interval.&quot;</span><span class="p">,</span>
            <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;A termination event occurred.&quot;</span><span class="p">}</span>


<span class="k">class</span><span class="w"> </span><span class="nc">OdeResult</span><span class="p">(</span><span class="n">OptimizeResult</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span><span class="w"> </span><span class="nf">prepare_events</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Standardize event functions and extract attributes.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
        <span class="n">events</span> <span class="o">=</span> <span class="p">(</span><span class="n">events</span><span class="p">,)</span>

    <span class="n">max_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">))</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">event</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
        <span class="n">terminal</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s1">&#39;terminal&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">direction</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s1">&#39;direction&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">message</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;The `terminal` attribute of each event &#39;</span>
                   <span class="s1">&#39;must be a boolean or positive integer.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">terminal</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">terminal</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">max_events</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">elif</span> <span class="nb">int</span><span class="p">(</span><span class="n">terminal</span><span class="p">)</span> <span class="o">==</span> <span class="n">terminal</span> <span class="ow">and</span> <span class="n">terminal</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">max_events</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">terminal</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">events</span><span class="p">,</span> <span class="n">max_events</span><span class="p">,</span> <span class="n">direction</span>


<span class="k">def</span><span class="w"> </span><span class="nf">solve_event_equation</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="n">t_old</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Solve an equation corresponding to an ODE event.</span>

<span class="sd">    The equation is ``event(t, y(t)) = 0``, here ``y(t)`` is known from an</span>
<span class="sd">    ODE solver using some sort of interpolation. It is solved by</span>
<span class="sd">    `scipy.optimize.brentq` with xtol=atol=4*EPS.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    event : callable</span>
<span class="sd">        Function ``event(t, y)``.</span>
<span class="sd">    sol : callable</span>
<span class="sd">        Function ``sol(t)`` which evaluates an ODE solution between `t_old`</span>
<span class="sd">        and  `t`.</span>
<span class="sd">    t_old, t : float</span>
<span class="sd">        Previous and new values of time. They will be used as a bracketing</span>
<span class="sd">        interval.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    root : float</span>
<span class="sd">        Found solution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">brentq</span>
    <span class="k">return</span> <span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">event</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sol</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">t_old</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span>
                  <span class="n">xtol</span><span class="o">=</span><span class="mi">4</span> <span class="o">*</span> <span class="n">EPS</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">4</span> <span class="o">*</span> <span class="n">EPS</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">handle_events</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">active_events</span><span class="p">,</span> <span class="n">event_count</span><span class="p">,</span> <span class="n">max_events</span><span class="p">,</span>
                  <span class="n">t_old</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function to handle events.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sol : DenseOutput</span>
<span class="sd">        Function ``sol(t)`` which evaluates an ODE solution between `t_old`</span>
<span class="sd">        and  `t`.</span>
<span class="sd">    events : list of callables, length n_events</span>
<span class="sd">        Event functions with signatures ``event(t, y)``.</span>
<span class="sd">    active_events : ndarray</span>
<span class="sd">        Indices of events which occurred.</span>
<span class="sd">    event_count : ndarray</span>
<span class="sd">        Current number of occurrences for each event.</span>
<span class="sd">    max_events : ndarray, shape (n_events,)</span>
<span class="sd">        Number of occurrences allowed for each event before integration</span>
<span class="sd">        termination is issued.</span>
<span class="sd">    t_old, t : float</span>
<span class="sd">        Previous and new values of time.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    root_indices : ndarray</span>
<span class="sd">        Indices of events which take zero between `t_old` and `t` and before</span>
<span class="sd">        a possible termination.</span>
<span class="sd">    roots : ndarray</span>
<span class="sd">        Values of t at which events occurred.</span>
<span class="sd">    terminate : bool</span>
<span class="sd">        Whether a terminal event occurred.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">roots</span> <span class="o">=</span> <span class="p">[</span><span class="n">solve_event_equation</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">event_index</span><span class="p">],</span> <span class="n">sol</span><span class="p">,</span> <span class="n">t_old</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">event_index</span> <span class="ow">in</span> <span class="n">active_events</span><span class="p">]</span>

    <span class="n">roots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">event_count</span><span class="p">[</span><span class="n">active_events</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">max_events</span><span class="p">[</span><span class="n">active_events</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">t_old</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">roots</span><span class="p">)</span>
        <span class="n">active_events</span> <span class="o">=</span> <span class="n">active_events</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="n">roots</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">event_count</span><span class="p">[</span><span class="n">active_events</span><span class="p">]</span>
                       <span class="o">&gt;=</span> <span class="n">max_events</span><span class="p">[</span><span class="n">active_events</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">active_events</span> <span class="o">=</span> <span class="n">active_events</span><span class="p">[:</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="n">roots</span><span class="p">[:</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">terminate</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">terminate</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">active_events</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">terminate</span>


<span class="k">def</span><span class="w"> </span><span class="nf">find_active_events</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g_new</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find which event occurred during an integration step.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    g, g_new : array_like, shape (n_events,)</span>
<span class="sd">        Values of event functions at a current and next points.</span>
<span class="sd">    direction : ndarray, shape (n_events,)</span>
<span class="sd">        Event &quot;direction&quot; according to the definition in `solve_ivp`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    active_events : ndarray</span>
<span class="sd">        Indices of events which occurred during the step.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g</span><span class="p">,</span> <span class="n">g_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">g_new</span><span class="p">)</span>
    <span class="n">up</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">g_new</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">down</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">g_new</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">either</span> <span class="o">=</span> <span class="n">up</span> <span class="o">|</span> <span class="n">down</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">up</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">direction</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
            <span class="n">down</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">direction</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
            <span class="n">either</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


<div class="viewcode-block" id="solve_ivp">
<a class="viewcode-back" href="../../../../_autosummary/pydune.physics.turbulent_flow.fourriere2010_unbounded.solve_ivp.html#pydune.physics.turbulent_flow.andreotti2009.solve_ivp">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">solve_ivp</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">t_span</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;RK45&#39;</span><span class="p">,</span> <span class="n">t_eval</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dense_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Solve an initial value problem for a system of ODEs.</span>

<span class="sd">    This function numerically integrates a system of ordinary differential</span>
<span class="sd">    equations given an initial value::</span>

<span class="sd">        dy / dt = f(t, y)</span>
<span class="sd">        y(t0) = y0</span>

<span class="sd">    Here t is a 1-D independent variable (time), y(t) is an</span>
<span class="sd">    N-D vector-valued function (state), and an N-D</span>
<span class="sd">    vector-valued function f(t, y) determines the differential equations.</span>
<span class="sd">    The goal is to find y(t) approximately satisfying the differential</span>
<span class="sd">    equations, given an initial value y(t0)=y0.</span>

<span class="sd">    Some of the solvers support integration in the complex domain, but note</span>
<span class="sd">    that for stiff ODE solvers, the right-hand side must be</span>
<span class="sd">    complex-differentiable (satisfy Cauchy-Riemann equations [11]_).</span>
<span class="sd">    To solve a problem in the complex domain, pass y0 with a complex data type.</span>
<span class="sd">    Another option always available is to rewrite your problem for real and</span>
<span class="sd">    imaginary parts separately.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fun : callable</span>
<span class="sd">        Right-hand side of the system: the time derivative of the state ``y``</span>
<span class="sd">        at time ``t``. The calling signature is ``fun(t, y)``, where ``t`` is a</span>
<span class="sd">        scalar and ``y`` is an ndarray with ``len(y) = len(y0)``. Additional</span>
<span class="sd">        arguments need to be passed if ``args`` is used (see documentation of</span>
<span class="sd">        ``args`` argument). ``fun`` must return an array of the same shape as</span>
<span class="sd">        ``y``. See `vectorized` for more information.</span>
<span class="sd">    t_span : 2-member sequence</span>
<span class="sd">        Interval of integration (t0, tf). The solver starts with t=t0 and</span>
<span class="sd">        integrates until it reaches t=tf. Both t0 and tf must be floats</span>
<span class="sd">        or values interpretable by the float conversion function.</span>
<span class="sd">    y0 : array_like, shape (n,)</span>
<span class="sd">        Initial state. For problems in the complex domain, pass `y0` with a</span>
<span class="sd">        complex data type (even if the initial value is purely real).</span>
<span class="sd">    method : string or `OdeSolver`, optional</span>
<span class="sd">        Integration method to use:</span>

<span class="sd">            * &#39;RK45&#39; (default): Explicit Runge-Kutta method of order 5(4) [1]_.</span>
<span class="sd">              The error is controlled assuming accuracy of the fourth-order</span>
<span class="sd">              method, but steps are taken using the fifth-order accurate</span>
<span class="sd">              formula (local extrapolation is done). A quartic interpolation</span>
<span class="sd">              polynomial is used for the dense output [2]_. Can be applied in</span>
<span class="sd">              the complex domain.</span>
<span class="sd">            * &#39;RK23&#39;: Explicit Runge-Kutta method of order 3(2) [3]_. The error</span>
<span class="sd">              is controlled assuming accuracy of the second-order method, but</span>
<span class="sd">              steps are taken using the third-order accurate formula (local</span>
<span class="sd">              extrapolation is done). A cubic Hermite polynomial is used for the</span>
<span class="sd">              dense output. Can be applied in the complex domain.</span>
<span class="sd">            * &#39;DOP853&#39;: Explicit Runge-Kutta method of order 8 [13]_.</span>
<span class="sd">              Python implementation of the &quot;DOP853&quot; algorithm originally</span>
<span class="sd">              written in Fortran [14]_. A 7-th order interpolation polynomial</span>
<span class="sd">              accurate to 7-th order is used for the dense output.</span>
<span class="sd">              Can be applied in the complex domain.</span>
<span class="sd">            * &#39;Radau&#39;: Implicit Runge-Kutta method of the Radau IIA family of</span>
<span class="sd">              order 5 [4]_. The error is controlled with a third-order accurate</span>
<span class="sd">              embedded formula. A cubic polynomial which satisfies the</span>
<span class="sd">              collocation conditions is used for the dense output.</span>
<span class="sd">            * &#39;BDF&#39;: Implicit multi-step variable-order (1 to 5) method based</span>
<span class="sd">              on a backward differentiation formula for the derivative</span>
<span class="sd">              approximation [5]_. The implementation follows the one described</span>
<span class="sd">              in [6]_. A quasi-constant step scheme is used and accuracy is</span>
<span class="sd">              enhanced using the NDF modification. Can be applied in the</span>
<span class="sd">              complex domain.</span>
<span class="sd">            * &#39;LSODA&#39;: Adams/BDF method with automatic stiffness detection and</span>
<span class="sd">              switching [7]_, [8]_. This is a wrapper of the Fortran solver</span>
<span class="sd">              from ODEPACK.</span>

<span class="sd">        Explicit Runge-Kutta methods (&#39;RK23&#39;, &#39;RK45&#39;, &#39;DOP853&#39;) should be used</span>
<span class="sd">        for non-stiff problems and implicit methods (&#39;Radau&#39;, &#39;BDF&#39;) for</span>
<span class="sd">        stiff problems [9]_. Among Runge-Kutta methods, &#39;DOP853&#39; is recommended</span>
<span class="sd">        for solving with high precision (low values of `rtol` and `atol`).</span>

<span class="sd">        If not sure, first try to run &#39;RK45&#39;. If it makes unusually many</span>
<span class="sd">        iterations, diverges, or fails, your problem is likely to be stiff and</span>
<span class="sd">        you should use &#39;Radau&#39; or &#39;BDF&#39;. &#39;LSODA&#39; can also be a good universal</span>
<span class="sd">        choice, but it might be somewhat less convenient to work with as it</span>
<span class="sd">        wraps old Fortran code.</span>

<span class="sd">        You can also pass an arbitrary class derived from `OdeSolver` which</span>
<span class="sd">        implements the solver.</span>
<span class="sd">    t_eval : array_like or None, optional</span>
<span class="sd">        Times at which to store the computed solution, must be sorted and lie</span>
<span class="sd">        within `t_span`. If None (default), use points selected by the solver.</span>
<span class="sd">    dense_output : bool, optional</span>
<span class="sd">        Whether to compute a continuous solution. Default is False.</span>
<span class="sd">    events : callable, or list of callables, optional</span>
<span class="sd">        Events to track. If None (default), no events will be tracked.</span>
<span class="sd">        Each event occurs at the zeros of a continuous function of time and</span>
<span class="sd">        state. Each function must have the signature ``event(t, y)`` where</span>
<span class="sd">        additional argument have to be passed if ``args`` is used (see</span>
<span class="sd">        documentation of ``args`` argument). Each function must return a</span>
<span class="sd">        float. The solver will find an accurate value of `t` at which</span>
<span class="sd">        ``event(t, y(t)) = 0`` using a root-finding algorithm. By default,</span>
<span class="sd">        all zeros will be found. The solver looks for a sign change over</span>
<span class="sd">        each step, so if multiple zero crossings occur within one step,</span>
<span class="sd">        events may be missed. Additionally each `event` function might</span>
<span class="sd">        have the following attributes:</span>

<span class="sd">            terminal: bool or int, optional</span>
<span class="sd">                When boolean, whether to terminate integration if this event occurs.</span>
<span class="sd">                When integral, termination occurs after the specified the number of</span>
<span class="sd">                occurrences of this event.</span>
<span class="sd">                Implicitly False if not assigned.</span>
<span class="sd">            direction: float, optional</span>
<span class="sd">                Direction of a zero crossing. If `direction` is positive,</span>
<span class="sd">                `event` will only trigger when going from negative to positive,</span>
<span class="sd">                and vice versa if `direction` is negative. If 0, then either</span>
<span class="sd">                direction will trigger event. Implicitly 0 if not assigned.</span>

<span class="sd">        You can assign attributes like ``event.terminal = True`` to any</span>
<span class="sd">        function in Python.</span>
<span class="sd">    vectorized : bool, optional</span>
<span class="sd">        Whether `fun` can be called in a vectorized fashion. Default is False.</span>

<span class="sd">        If ``vectorized`` is False, `fun` will always be called with ``y`` of</span>
<span class="sd">        shape ``(n,)``, where ``n = len(y0)``.</span>

<span class="sd">        If ``vectorized`` is True, `fun` may be called with ``y`` of shape</span>
<span class="sd">        ``(n, k)``, where ``k`` is an integer. In this case, `fun` must behave</span>
<span class="sd">        such that ``fun(t, y)[:, i] == fun(t, y[:, i])`` (i.e. each column of</span>
<span class="sd">        the returned array is the time derivative of the state corresponding</span>
<span class="sd">        with a column of ``y``).</span>

<span class="sd">        Setting ``vectorized=True`` allows for faster finite difference</span>
<span class="sd">        approximation of the Jacobian by methods &#39;Radau&#39; and &#39;BDF&#39;, but</span>
<span class="sd">        will result in slower execution for other methods and for &#39;Radau&#39; and</span>
<span class="sd">        &#39;BDF&#39; in some circumstances (e.g. small ``len(y0)``).</span>
<span class="sd">    args : tuple, optional</span>
<span class="sd">        Additional arguments to pass to the user-defined functions.  If given,</span>
<span class="sd">        the additional arguments are passed to all user-defined functions.</span>
<span class="sd">        So if, for example, `fun` has the signature ``fun(t, y, a, b, c)``,</span>
<span class="sd">        then `jac` (if given) and any event functions must have the same</span>
<span class="sd">        signature, and `args` must be a tuple of length 3.</span>
<span class="sd">    **options</span>
<span class="sd">        Options passed to a chosen solver. All options available for already</span>
<span class="sd">        implemented solvers are listed below.</span>
<span class="sd">    first_step : float or None, optional</span>
<span class="sd">        Initial step size. Default is `None` which means that the algorithm</span>
<span class="sd">        should choose.</span>
<span class="sd">    max_step : float, optional</span>
<span class="sd">        Maximum allowed step size. Default is np.inf, i.e., the step size is not</span>
<span class="sd">        bounded and determined solely by the solver.</span>
<span class="sd">    rtol, atol : float or array_like, optional</span>
<span class="sd">        Relative and absolute tolerances. The solver keeps the local error</span>
<span class="sd">        estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a</span>
<span class="sd">        relative accuracy (number of correct digits), while `atol` controls</span>
<span class="sd">        absolute accuracy (number of correct decimal places). To achieve the</span>
<span class="sd">        desired `rtol`, set `atol` to be smaller than the smallest value that</span>
<span class="sd">        can be expected from ``rtol * abs(y)`` so that `rtol` dominates the</span>
<span class="sd">        allowable error. If `atol` is larger than ``rtol * abs(y)`` the</span>
<span class="sd">        number of correct digits is not guaranteed. Conversely, to achieve the</span>
<span class="sd">        desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller</span>
<span class="sd">        than `atol`. If components of y have different scales, it might be</span>
<span class="sd">        beneficial to set different `atol` values for different components by</span>
<span class="sd">        passing array_like with shape (n,) for `atol`. Default values are</span>
<span class="sd">        1e-3 for `rtol` and 1e-6 for `atol`.</span>
<span class="sd">    jac : array_like, sparse_matrix, callable or None, optional</span>
<span class="sd">        Jacobian matrix of the right-hand side of the system with respect</span>
<span class="sd">        to y, required by the &#39;Radau&#39;, &#39;BDF&#39; and &#39;LSODA&#39; method. The</span>
<span class="sd">        Jacobian matrix has shape (n, n) and its element (i, j) is equal to</span>
<span class="sd">        ``d f_i / d y_j``.  There are three ways to define the Jacobian:</span>

<span class="sd">            * If array_like or sparse_matrix, the Jacobian is assumed to</span>
<span class="sd">              be constant. Not supported by &#39;LSODA&#39;.</span>
<span class="sd">            * If callable, the Jacobian is assumed to depend on both</span>
<span class="sd">              t and y; it will be called as ``jac(t, y)``, as necessary.</span>
<span class="sd">              Additional arguments have to be passed if ``args`` is</span>
<span class="sd">              used (see documentation of ``args`` argument).</span>
<span class="sd">              For &#39;Radau&#39; and &#39;BDF&#39; methods, the return value might be a</span>
<span class="sd">              sparse matrix.</span>
<span class="sd">            * If None (default), the Jacobian will be approximated by</span>
<span class="sd">              finite differences.</span>

<span class="sd">        It is generally recommended to provide the Jacobian rather than</span>
<span class="sd">        relying on a finite-difference approximation.</span>
<span class="sd">    jac_sparsity : array_like, sparse matrix or None, optional</span>
<span class="sd">        Defines a sparsity structure of the Jacobian matrix for a finite-</span>
<span class="sd">        difference approximation. Its shape must be (n, n). This argument</span>
<span class="sd">        is ignored if `jac` is not `None`. If the Jacobian has only few</span>
<span class="sd">        non-zero elements in *each* row, providing the sparsity structure</span>
<span class="sd">        will greatly speed up the computations [10]_. A zero entry means that</span>
<span class="sd">        a corresponding element in the Jacobian is always zero. If None</span>
<span class="sd">        (default), the Jacobian is assumed to be dense.</span>
<span class="sd">        Not supported by &#39;LSODA&#39;, see `lband` and `uband` instead.</span>
<span class="sd">    lband, uband : int or None, optional</span>
<span class="sd">        Parameters defining the bandwidth of the Jacobian for the &#39;LSODA&#39;</span>
<span class="sd">        method, i.e., ``jac[i, j] != 0 only for i - lband &lt;= j &lt;= i + uband``.</span>
<span class="sd">        Default is None. Setting these requires your jac routine to return the</span>
<span class="sd">        Jacobian in the packed format: the returned array must have ``n``</span>
<span class="sd">        columns and ``uband + lband + 1`` rows in which Jacobian diagonals are</span>
<span class="sd">        written. Specifically ``jac_packed[uband + i - j , j] = jac[i, j]``.</span>
<span class="sd">        The same format is used in `scipy.linalg.solve_banded` (check for an</span>
<span class="sd">        illustration).  These parameters can be also used with ``jac=None`` to</span>
<span class="sd">        reduce the number of Jacobian elements estimated by finite differences.</span>
<span class="sd">    min_step : float, optional</span>
<span class="sd">        The minimum allowed step size for &#39;LSODA&#39; method.</span>
<span class="sd">        By default `min_step` is zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Bunch object with the following fields defined:</span>
<span class="sd">    t : ndarray, shape (n_points,)</span>
<span class="sd">        Time points.</span>
<span class="sd">    y : ndarray, shape (n, n_points)</span>
<span class="sd">        Values of the solution at `t`.</span>
<span class="sd">    sol : `OdeSolution` or None</span>
<span class="sd">        Found solution as `OdeSolution` instance; None if `dense_output` was</span>
<span class="sd">        set to False.</span>
<span class="sd">    t_events : list of ndarray or None</span>
<span class="sd">        Contains for each event type a list of arrays at which an event of</span>
<span class="sd">        that type event was detected. None if `events` was None.</span>
<span class="sd">    y_events : list of ndarray or None</span>
<span class="sd">        For each value of `t_events`, the corresponding value of the solution.</span>
<span class="sd">        None if `events` was None.</span>
<span class="sd">    nfev : int</span>
<span class="sd">        Number of evaluations of the right-hand side.</span>
<span class="sd">    njev : int</span>
<span class="sd">        Number of evaluations of the Jacobian.</span>
<span class="sd">    nlu : int</span>
<span class="sd">        Number of LU decompositions.</span>
<span class="sd">    status : int</span>
<span class="sd">        Reason for algorithm termination:</span>

<span class="sd">            * -1: Integration step failed.</span>
<span class="sd">            *  0: The solver successfully reached the end of `tspan`.</span>
<span class="sd">            *  1: A termination event occurred.</span>

<span class="sd">    message : string</span>
<span class="sd">        Human-readable description of the termination reason.</span>
<span class="sd">    success : bool</span>
<span class="sd">        True if the solver reached the interval end or a termination event</span>
<span class="sd">        occurred (``status &gt;= 0``).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] J. R. Dormand, P. J. Prince, &quot;A family of embedded Runge-Kutta</span>
<span class="sd">           formulae&quot;, Journal of Computational and Applied Mathematics, Vol. 6,</span>
<span class="sd">           No. 1, pp. 19-26, 1980.</span>
<span class="sd">    .. [2] L. W. Shampine, &quot;Some Practical Runge-Kutta Formulas&quot;, Mathematics</span>
<span class="sd">           of Computation,, Vol. 46, No. 173, pp. 135-150, 1986.</span>
<span class="sd">    .. [3] P. Bogacki, L.F. Shampine, &quot;A 3(2) Pair of Runge-Kutta Formulas&quot;,</span>
<span class="sd">           Appl. Math. Lett. Vol. 2, No. 4. pp. 321-325, 1989.</span>
<span class="sd">    .. [4] E. Hairer, G. Wanner, &quot;Solving Ordinary Differential Equations II:</span>
<span class="sd">           Stiff and Differential-Algebraic Problems&quot;, Sec. IV.8.</span>
<span class="sd">    .. [5] `Backward Differentiation Formula</span>
<span class="sd">            &lt;https://en.wikipedia.org/wiki/Backward_differentiation_formula&gt;`_</span>
<span class="sd">            on Wikipedia.</span>
<span class="sd">    .. [6] L. F. Shampine, M. W. Reichelt, &quot;THE MATLAB ODE SUITE&quot;, SIAM J. SCI.</span>
<span class="sd">           COMPUTE., Vol. 18, No. 1, pp. 1-22, January 1997.</span>
<span class="sd">    .. [7] A. C. Hindmarsh, &quot;ODEPACK, A Systematized Collection of ODE</span>
<span class="sd">           Solvers,&quot; IMACS Transactions on Scientific Computation, Vol 1.,</span>
<span class="sd">           pp. 55-64, 1983.</span>
<span class="sd">    .. [8] L. Petzold, &quot;Automatic selection of methods for solving stiff and</span>
<span class="sd">           nonstiff systems of ordinary differential equations&quot;, SIAM Journal</span>
<span class="sd">           on Scientific and Statistical Computing, Vol. 4, No. 1, pp. 136-148,</span>
<span class="sd">           1983.</span>
<span class="sd">    .. [9] `Stiff equation &lt;https://en.wikipedia.org/wiki/Stiff_equation&gt;`_ on</span>
<span class="sd">           Wikipedia.</span>
<span class="sd">    .. [10] A. Curtis, M. J. D. Powell, and J. Reid, &quot;On the estimation of</span>
<span class="sd">            sparse Jacobian matrices&quot;, Journal of the Institute of Mathematics</span>
<span class="sd">            and its Applications, 13, pp. 117-120, 1974.</span>
<span class="sd">    .. [11] `Cauchy-Riemann equations</span>
<span class="sd">             &lt;https://en.wikipedia.org/wiki/Cauchy-Riemann_equations&gt;`_ on</span>
<span class="sd">             Wikipedia.</span>
<span class="sd">    .. [12] `Lotka-Volterra equations</span>
<span class="sd">            &lt;https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equations&gt;`_</span>
<span class="sd">            on Wikipedia.</span>
<span class="sd">    .. [13] E. Hairer, S. P. Norsett G. Wanner, &quot;Solving Ordinary Differential</span>
<span class="sd">            Equations I: Nonstiff Problems&quot;, Sec. II.</span>
<span class="sd">    .. [14] `Page with original Fortran code of DOP853</span>
<span class="sd">            &lt;http://www.unige.ch/~hairer/software.html&gt;`_.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Basic exponential decay showing automatically chosen time points.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.integrate import solve_ivp</span>
<span class="sd">    &gt;&gt;&gt; def exponential_decay(t, y): return -0.5 * y</span>
<span class="sd">    &gt;&gt;&gt; sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8])</span>
<span class="sd">    &gt;&gt;&gt; print(sol.t)</span>
<span class="sd">    [ 0.          0.11487653  1.26364188  3.06061781  4.81611105  6.57445806</span>
<span class="sd">      8.33328988 10.        ]</span>
<span class="sd">    &gt;&gt;&gt; print(sol.y)</span>
<span class="sd">    [[2.         1.88836035 1.06327177 0.43319312 0.18017253 0.07483045</span>
<span class="sd">      0.03107158 0.01350781]</span>
<span class="sd">     [4.         3.7767207  2.12654355 0.86638624 0.36034507 0.14966091</span>
<span class="sd">      0.06214316 0.02701561]</span>
<span class="sd">     [8.         7.5534414  4.25308709 1.73277247 0.72069014 0.29932181</span>
<span class="sd">      0.12428631 0.05403123]]</span>

<span class="sd">    Specifying points where the solution is desired.</span>

<span class="sd">    &gt;&gt;&gt; sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8],</span>
<span class="sd">    ...                 t_eval=[0, 1, 2, 4, 10])</span>
<span class="sd">    &gt;&gt;&gt; print(sol.t)</span>
<span class="sd">    [ 0  1  2  4 10]</span>
<span class="sd">    &gt;&gt;&gt; print(sol.y)</span>
<span class="sd">    [[2.         1.21305369 0.73534021 0.27066736 0.01350938]</span>
<span class="sd">     [4.         2.42610739 1.47068043 0.54133472 0.02701876]</span>
<span class="sd">     [8.         4.85221478 2.94136085 1.08266944 0.05403753]]</span>

<span class="sd">    Cannon fired upward with terminal event upon impact. The ``terminal`` and</span>
<span class="sd">    ``direction`` fields of an event are applied by monkey patching a function.</span>
<span class="sd">    Here ``y[0]`` is position and ``y[1]`` is velocity. The projectile starts</span>
<span class="sd">    at position 0 with velocity +10. Note that the integration never reaches</span>
<span class="sd">    t=100 because the event is terminal.</span>

<span class="sd">    &gt;&gt;&gt; def upward_cannon(t, y): return [y[1], -0.5]</span>
<span class="sd">    &gt;&gt;&gt; def hit_ground(t, y): return y[0]</span>
<span class="sd">    &gt;&gt;&gt; hit_ground.terminal = True</span>
<span class="sd">    &gt;&gt;&gt; hit_ground.direction = -1</span>
<span class="sd">    &gt;&gt;&gt; sol = solve_ivp(upward_cannon, [0, 100], [0, 10], events=hit_ground)</span>
<span class="sd">    &gt;&gt;&gt; print(sol.t_events)</span>
<span class="sd">    [array([40.])]</span>
<span class="sd">    &gt;&gt;&gt; print(sol.t)</span>
<span class="sd">    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02</span>
<span class="sd">     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]</span>

<span class="sd">    Use `dense_output` and `events` to find position, which is 100, at the apex</span>
<span class="sd">    of the cannonball&#39;s trajectory. Apex is not defined as terminal, so both</span>
<span class="sd">    apex and hit_ground are found. There is no information at t=20, so the sol</span>
<span class="sd">    attribute is used to evaluate the solution. The sol attribute is returned</span>
<span class="sd">    by setting ``dense_output=True``. Alternatively, the `y_events` attribute</span>
<span class="sd">    can be used to access the solution at the time of the event.</span>

<span class="sd">    &gt;&gt;&gt; def apex(t, y): return y[1]</span>
<span class="sd">    &gt;&gt;&gt; sol = solve_ivp(upward_cannon, [0, 100], [0, 10],</span>
<span class="sd">    ...                 events=(hit_ground, apex), dense_output=True)</span>
<span class="sd">    &gt;&gt;&gt; print(sol.t_events)</span>
<span class="sd">    [array([40.]), array([20.])]</span>
<span class="sd">    &gt;&gt;&gt; print(sol.t)</span>
<span class="sd">    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02</span>
<span class="sd">     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]</span>
<span class="sd">    &gt;&gt;&gt; print(sol.sol(sol.t_events[1][0]))</span>
<span class="sd">    [100.   0.]</span>
<span class="sd">    &gt;&gt;&gt; print(sol.y_events)</span>
<span class="sd">    [array([[-5.68434189e-14, -1.00000000e+01]]),</span>
<span class="sd">     array([[1.00000000e+02, 1.77635684e-15]])]</span>

<span class="sd">    As an example of a system with additional parameters, we&#39;ll implement</span>
<span class="sd">    the Lotka-Volterra equations [12]_.</span>

<span class="sd">    &gt;&gt;&gt; def lotkavolterra(t, z, a, b, c, d):</span>
<span class="sd">    ...     x, y = z</span>
<span class="sd">    ...     return [a*x - b*x*y, -c*y + d*x*y]</span>
<span class="sd">    ...</span>

<span class="sd">    We pass in the parameter values a=1.5, b=1, c=3 and d=1 with the `args`</span>
<span class="sd">    argument.</span>

<span class="sd">    &gt;&gt;&gt; sol = solve_ivp(lotkavolterra, [0, 15], [10, 5], args=(1.5, 1, 3, 1),</span>
<span class="sd">    ...                 dense_output=True)</span>

<span class="sd">    Compute a dense solution and plot it.</span>

<span class="sd">    &gt;&gt;&gt; t = np.linspace(0, 15, 300)</span>
<span class="sd">    &gt;&gt;&gt; z = sol.sol(t)</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(t, z.T)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;t&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend([&#39;x&#39;, &#39;y&#39;], shadow=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&#39;Lotka-Volterra System&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    A couple examples of using solve_ivp to solve the differential</span>
<span class="sd">    equation ``y&#39; = Ay`` with complex matrix ``A``.</span>

<span class="sd">    &gt;&gt;&gt; A = np.array([[-0.25 + 0.14j, 0, 0.33 + 0.44j],</span>
<span class="sd">    ...               [0.25 + 0.58j, -0.2 + 0.14j, 0],</span>
<span class="sd">    ...               [0, 0.2 + 0.4j, -0.1 + 0.97j]])</span>

<span class="sd">    Solving an IVP with ``A`` from above and ``y`` as 3x1 vector:</span>

<span class="sd">    &gt;&gt;&gt; def deriv_vec(t, y):</span>
<span class="sd">    ...     return A @ y</span>
<span class="sd">    &gt;&gt;&gt; result = solve_ivp(deriv_vec, [0, 25],</span>
<span class="sd">    ...                    np.array([10 + 0j, 20 + 0j, 30 + 0j]),</span>
<span class="sd">    ...                    t_eval=np.linspace(0, 25, 101))</span>
<span class="sd">    &gt;&gt;&gt; print(result.y[:, 0])</span>
<span class="sd">    [10.+0.j 20.+0.j 30.+0.j]</span>
<span class="sd">    &gt;&gt;&gt; print(result.y[:, -1])</span>
<span class="sd">    [18.46291039+45.25653651j 10.01569306+36.23293216j</span>
<span class="sd">     -4.98662741+80.07360388j]</span>

<span class="sd">    Solving an IVP with ``A`` from above with ``y`` as 3x3 matrix :</span>

<span class="sd">    &gt;&gt;&gt; def deriv_mat(t, y):</span>
<span class="sd">    ...     return (A @ y.reshape(3, 3)).flatten()</span>
<span class="sd">    &gt;&gt;&gt; y0 = np.array([[2 + 0j, 3 + 0j, 4 + 0j],</span>
<span class="sd">    ...                [5 + 0j, 6 + 0j, 7 + 0j],</span>
<span class="sd">    ...                [9 + 0j, 34 + 0j, 78 + 0j]])</span>

<span class="sd">    &gt;&gt;&gt; result = solve_ivp(deriv_mat, [0, 25], y0.flatten(),</span>
<span class="sd">    ...                    t_eval=np.linspace(0, 25, 101))</span>
<span class="sd">    &gt;&gt;&gt; print(result.y[:, 0].reshape(3, 3))</span>
<span class="sd">    [[ 2.+0.j  3.+0.j  4.+0.j]</span>
<span class="sd">     [ 5.+0.j  6.+0.j  7.+0.j]</span>
<span class="sd">     [ 9.+0.j 34.+0.j 78.+0.j]]</span>
<span class="sd">    &gt;&gt;&gt; print(result.y[:, -1].reshape(3, 3))</span>
<span class="sd">    [[  5.67451179 +12.07938445j  17.2888073  +31.03278837j</span>
<span class="sd">        37.83405768 +63.25138759j]</span>
<span class="sd">     [  3.39949503 +11.82123994j  21.32530996 +44.88668871j</span>
<span class="sd">        53.17531184+103.80400411j]</span>
<span class="sd">     [ -2.26105874 +22.19277664j -15.1255713  +70.19616341j</span>
<span class="sd">       -38.34616845+153.29039931j]]</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">METHODS</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">method</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">OdeSolver</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`method` must be one of </span><span class="si">{</span><span class="n">METHODS</span><span class="si">}</span><span class="s2"> or OdeSolver class.&quot;</span><span class="p">)</span>

    <span class="n">t0</span><span class="p">,</span> <span class="n">tf</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">t_span</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Wrap the user&#39;s fun (and jac, if given) in lambdas to hide the</span>
        <span class="c1"># additional parameters.  Pass in the original fun as a keyword</span>
        <span class="c1"># argument to keep it in the scope of the lambda.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="p">(</span><span class="n">args</span><span class="p">)]</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">exp</span><span class="p">:</span>
            <span class="n">suggestion_tuple</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Supplied &#39;args&#39; cannot be unpacked. Please supply `args`&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; as a tuple (e.g. `args=(</span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s2">,)`)&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">suggestion_tuple</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">exp</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">fun</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">fun</span><span class="o">=</span><span class="n">fun</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;jac&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">jac</span><span class="p">):</span>
            <span class="n">options</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">jac</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">t_eval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t_eval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t_eval</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t_eval</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`t_eval` must be 1-dimensional.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">t_eval</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">tf</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">t_eval</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">tf</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Values in `t_eval` are not within `t_span`.&quot;</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t_eval</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tf</span> <span class="o">&gt;</span> <span class="n">t0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">d</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">tf</span> <span class="o">&lt;</span> <span class="n">t0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Values in `t_eval` are not properly sorted.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tf</span> <span class="o">&gt;</span> <span class="n">t0</span><span class="p">:</span>
            <span class="n">t_eval_i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Make order of t_eval decreasing to use np.searchsorted.</span>
            <span class="n">t_eval</span> <span class="o">=</span> <span class="n">t_eval</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># This will be an upper bound for slices.</span>
            <span class="n">t_eval_i</span> <span class="o">=</span> <span class="n">t_eval</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">METHODS</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">METHODS</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>

    <span class="n">solver</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="n">vectorized</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">t_eval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="p">[</span><span class="n">t0</span><span class="p">]</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="n">y0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">t_eval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dense_output</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ti</span> <span class="o">=</span> <span class="p">[</span><span class="n">t0</span><span class="p">]</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">interpolants</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">events</span><span class="p">,</span> <span class="n">max_events</span><span class="p">,</span> <span class="n">event_dir</span> <span class="o">=</span> <span class="n">prepare_events</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
        <span class="n">event_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Wrap user functions in lambdas to hide the additional parameters.</span>
            <span class="c1"># The original event function is passed as a keyword argument to the</span>
            <span class="c1"># lambda to keep the original function in scope (i.e., avoid the</span>
            <span class="c1"># late binding closure &quot;gotcha&quot;).</span>
            <span class="n">events</span> <span class="o">=</span> <span class="p">[</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">event</span><span class="o">=</span><span class="n">event</span><span class="p">:</span> <span class="n">event</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">]</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="n">event</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span> <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">]</span>
        <span class="n">t_events</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">))]</span>
        <span class="n">y_events</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">))]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t_events</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">y_events</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">status</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">while</span> <span class="n">status</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">solver</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="s1">&#39;finished&#39;</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">solver</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="s1">&#39;failed&#39;</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">break</span>

        <span class="n">t_old</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">t_old</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">t</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">y</span>

        <span class="k">if</span> <span class="n">dense_output</span><span class="p">:</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">dense_output</span><span class="p">()</span>
            <span class="n">interpolants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g_new</span> <span class="o">=</span> <span class="p">[</span><span class="n">event</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">]</span>
            <span class="n">active_events</span> <span class="o">=</span> <span class="n">find_active_events</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">g_new</span><span class="p">,</span> <span class="n">event_dir</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">active_events</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sol</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">dense_output</span><span class="p">()</span>

                <span class="n">event_count</span><span class="p">[</span><span class="n">active_events</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">root_indices</span><span class="p">,</span> <span class="n">roots</span><span class="p">,</span> <span class="n">terminate</span> <span class="o">=</span> <span class="n">handle_events</span><span class="p">(</span>
                    <span class="n">sol</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">active_events</span><span class="p">,</span> <span class="n">event_count</span><span class="p">,</span> <span class="n">max_events</span><span class="p">,</span>
                    <span class="n">t_old</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">te</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">root_indices</span><span class="p">,</span> <span class="n">roots</span><span class="p">):</span>
                    <span class="n">t_events</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">te</span><span class="p">)</span>
                    <span class="n">y_events</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol</span><span class="p">(</span><span class="n">te</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">terminate</span><span class="p">:</span>
                    <span class="n">status</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">roots</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">sol</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="n">g</span> <span class="o">=</span> <span class="n">g_new</span>

        <span class="k">if</span> <span class="n">t_eval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">donot_append</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span>
                            <span class="n">ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span> <span class="ow">and</span>
                            <span class="n">dense_output</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">donot_append</span><span class="p">:</span>
                <span class="n">ts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">interpolants</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">interpolants</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The value in t_eval equal to t will be included.</span>
            <span class="k">if</span> <span class="n">solver</span><span class="o">.</span><span class="n">direction</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">t_eval_i_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t_eval</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
                <span class="n">t_eval_step</span> <span class="o">=</span> <span class="n">t_eval</span><span class="p">[</span><span class="n">t_eval_i</span><span class="p">:</span><span class="n">t_eval_i_new</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t_eval_i_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">t_eval</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
                <span class="c1"># It has to be done with two slice operations, because</span>
                <span class="c1"># you can&#39;t slice to 0th element inclusive using backward</span>
                <span class="c1"># slicing.</span>
                <span class="n">t_eval_step</span> <span class="o">=</span> <span class="n">t_eval</span><span class="p">[</span><span class="n">t_eval_i_new</span><span class="p">:</span><span class="n">t_eval_i</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">t_eval_step</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sol</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">dense_output</span><span class="p">()</span>
                <span class="n">ts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t_eval_step</span><span class="p">)</span>
                <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol</span><span class="p">(</span><span class="n">t_eval_step</span><span class="p">))</span>
                <span class="n">t_eval_i</span> <span class="o">=</span> <span class="n">t_eval_i_new</span>

        <span class="k">if</span> <span class="n">t_eval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dense_output</span><span class="p">:</span>
            <span class="n">ti</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="n">message</span> <span class="o">=</span> <span class="n">MESSAGES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">t_events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t_events</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">te</span><span class="p">)</span> <span class="k">for</span> <span class="n">te</span> <span class="ow">in</span> <span class="n">t_events</span><span class="p">]</span>
        <span class="n">y_events</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ye</span><span class="p">)</span> <span class="k">for</span> <span class="n">ye</span> <span class="ow">in</span> <span class="n">y_events</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">t_eval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">elif</span> <span class="n">ts</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dense_output</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">t_eval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">OdeSolution</span><span class="p">(</span>
                <span class="n">ts</span><span class="p">,</span> <span class="n">interpolants</span><span class="p">,</span> <span class="n">alt_segment</span><span class="o">=</span><span class="kc">True</span> <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="n">BDF</span><span class="p">,</span> <span class="n">LSODA</span><span class="p">]</span> <span class="k">else</span> <span class="kc">False</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">OdeSolution</span><span class="p">(</span>
                <span class="n">ti</span><span class="p">,</span> <span class="n">interpolants</span><span class="p">,</span> <span class="n">alt_segment</span><span class="o">=</span><span class="kc">True</span> <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="n">BDF</span><span class="p">,</span> <span class="n">LSODA</span><span class="p">]</span> <span class="k">else</span> <span class="kc">False</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">OdeResult</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">ts</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">ys</span><span class="p">,</span> <span class="n">sol</span><span class="o">=</span><span class="n">sol</span><span class="p">,</span> <span class="n">t_events</span><span class="o">=</span><span class="n">t_events</span><span class="p">,</span> <span class="n">y_events</span><span class="o">=</span><span class="n">y_events</span><span class="p">,</span>
                     <span class="n">nfev</span><span class="o">=</span><span class="n">solver</span><span class="o">.</span><span class="n">nfev</span><span class="p">,</span> <span class="n">njev</span><span class="o">=</span><span class="n">solver</span><span class="o">.</span><span class="n">njev</span><span class="p">,</span> <span class="n">nlu</span><span class="o">=</span><span class="n">solver</span><span class="o">.</span><span class="n">nlu</span><span class="p">,</span>
                     <span class="n">status</span><span class="o">=</span><span class="n">status</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span> <span class="n">success</span><span class="o">=</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span></div>

</pre></div>

                </article>
              
              
              
              
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2021, Cyril Gadal.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>